/*
 * Benchmark common math operations on the target MCU and display in CLI
 *
 * Copyright 2024 Till Blaha (Delft University of Technology)
 *
 * This file is part of Indiflight.
 *
 * Indiflight is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 *
 * Indiflight is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.
 *
 * If not, see <https://www.gnu.org/licenses/>.
 */


#include "platform.h"

#ifdef USE_BENCHMARK

#include "common/time.h"    // cmpTimeCycles
#include "drivers/system.h" // getCycleCounter
#include "drivers/io.h"
#include "benchmark.h"

#define CONCAT_P(a, b) a.b

#define BENCH_TIC { \
    __disable_irq(); \
    cycles = getCycleCounter(); \
}

#define BENCH_TOC(_test, _driver, _dtype) { \
    CONCAT_P(benchCounters[_test][_driver], _dtype) = cmpTimeCycles(getCycleCounter(), cycles); \
    __enable_irq(); \
}

// from random import random
// ", ".join([str(random()*0.98+0.01)+"f" for i in range(100)])
FAST_DATA static const int16_t rand_i16[BENCH_REPEAT] = { 9914, 17134, 18884, 10304, 1760, 2246, 30708, 16914, 19764, 27388, 20011, 26061, 1892, 18208, 28264, 22802, 15878, 4184, 7656, 15915, 6835, 1601, 22464, 21529, 19097, 28577, 8448, 19917, 17524, 6534, 28887, 686, 31455, 13912, 14190, 8907, 2040, 7667, 2744, 20382, 29420, 19888, 2607, 18422, 17690, 1260, 19744, 25142, 22910, 19384, 22963, 29950, 3058, 4292, 19744, 97, 6940, 31917, 15180, 11496, 7260, 27588, 5075, 15462, 11100, 6552, 32225, 15969, 30983, 3404, 8307, 19418, 11048, 6283, 9894, 23977, 27358, 7418, 11284, 12731, 17318, 20396, 14058, 32478, 3128, 16527, 14628, 30830, 1793, 13623, 30456, 14786, 1763, 1159, 1864, 14369, 11150, 4251, 14302, 22849 };
FAST_DATA static const int32_t rand_i32[BENCH_REPEAT] = { 9914, 17134, 18884, 10304, 1760, 2246, 30708, 16914, 19764, 27388, 20011, 26061, 1892, 18208, 28264, 22802, 15878, 4184, 7656, 15915, 6835, 1601, 22464, 21529, 19097, 28577, 8448, 19917, 17524, 6534, 28887, 686, 31455, 13912, 14190, 8907, 2040, 7667, 2744, 20382, 29420, 19888, 2607, 18422, 17690, 1260, 19744, 25142, 22910, 19384, 22963, 29950, 3058, 4292, 19744, 97, 6940, 31917, 15180, 11496, 7260, 27588, 5075, 15462, 11100, 6552, 32225, 15969, 30983, 3404, 8307, 19418, 11048, 6283, 9894, 23977, 27358, 7418, 11284, 12731, 17318, 20396, 14058, 32478, 3128, 16527, 14628, 30830, 1793, 13623, 30456, 14786, 1763, 1159, 1864, 14369, 11150, 4251, 14302, 22849 };
FAST_DATA static const float rand_f32[BENCH_REPEAT] = { 0.0166685644379091f, 0.9297499827974945f, 0.2633337520839668f, 0.9014106038417354f, 0.5003694786711683f, 0.9193276045953728f, 0.5002219563654186f, 0.38081627348525965f, 0.657440720516638f, 0.7454590134619185f, 0.12759467648131964f, 0.7279358241559001f, 0.2838962907477586f, 0.35580940056038773f, 0.10303010073016508f, 0.5157210272233574f, 0.30171591854485474f, 0.4129789726331639f, 0.8887200866548883f, 0.11447859047023054f, 0.9863775395760697f, 0.8675845559205643f, 0.5841585033658138f, 0.06328902589965674f, 0.4198259841257471f, 0.24434719449698816f, 0.5985434886992878f, 0.7254814389918204f, 0.8836480607602613f, 0.8167002799585192f, 0.7197513647823808f, 0.4063947991765638f, 0.6148989181532697f, 0.3514778552815623f, 0.965622001914734f, 0.4081108276731425f, 0.492527913260352f, 0.03212175318287194f, 0.8591050294726581f, 0.938452436484632f, 0.3230060245290801f, 0.7171290875828222f, 0.9110153752789766f, 0.984872528904854f, 0.5848620708991783f, 0.027897484179083512f, 0.5748566342753317f, 0.21044862670032452f, 0.9854488830864826f, 0.8958279380548647f, 0.2444599181867631f, 0.09123320151823856f, 0.6778498574663433f, 0.6758601523380467f, 0.7337629430719812f, 0.6214008517225071f, 0.033802676393829036f, 0.04764638109159293f, 0.5884045889113672f, 0.7781609439178464f, 0.7816463635639105f, 0.7898728512117497f, 0.9507468622796366f, 0.23557717853526874f, 0.6638784974704052f, 0.22913160557639461f, 0.08236634467587743f, 0.339977003899401f, 0.36407037103512746f, 0.6057556785474101f, 0.2208851005212594f, 0.19400462334533938f, 0.9327603320642109f, 0.21927290648533868f, 0.727786587197712f, 0.5222340998781466f, 0.9597824801035595f, 0.39342540484360317f, 0.8916304709052092f, 0.21313001472946488f, 0.9797964706250746f, 0.05751043738304441f, 0.8342027764850524f, 0.4528211452252113f, 0.4347573233806131f, 0.4525411381505408f, 0.35685716163304854f, 0.9799970768613392f, 0.20180396139642268f, 0.4605625409537868f, 0.7582300192604214f, 0.44455481065132474f, 0.9167197080840046f, 0.9407625684841503f, 0.08811121855541283f, 0.6765023754723515f, 0.665770167332321f, 0.5749834538155998f, 0.3527438102069729f, 0.6909342497128699f };
FAST_DATA static const double rand_f64[BENCH_REPEAT] = { 0.0166685644379091, 0.9297499827974945, 0.2633337520839668, 0.9014106038417354, 0.5003694786711683, 0.9193276045953728, 0.5002219563654186, 0.38081627348525965, 0.657440720516638, 0.7454590134619185, 0.12759467648131964, 0.7279358241559001, 0.2838962907477586, 0.35580940056038773, 0.10303010073016508, 0.5157210272233574, 0.30171591854485474, 0.4129789726331639, 0.8887200866548883, 0.11447859047023054, 0.9863775395760697, 0.8675845559205643, 0.5841585033658138, 0.06328902589965674, 0.4198259841257471, 0.24434719449698816, 0.5985434886992878, 0.7254814389918204, 0.8836480607602613, 0.8167002799585192, 0.7197513647823808, 0.4063947991765638, 0.6148989181532697, 0.3514778552815623, 0.965622001914734, 0.4081108276731425, 0.492527913260352, 0.03212175318287194, 0.8591050294726581, 0.938452436484632, 0.3230060245290801, 0.7171290875828222, 0.9110153752789766, 0.984872528904854, 0.5848620708991783, 0.027897484179083512, 0.5748566342753317, 0.21044862670032452, 0.9854488830864826, 0.8958279380548647, 0.2444599181867631, 0.09123320151823856, 0.6778498574663433, 0.6758601523380467, 0.7337629430719812, 0.6214008517225071, 0.033802676393829036, 0.04764638109159293, 0.5884045889113672, 0.7781609439178464, 0.7816463635639105, 0.7898728512117497, 0.9507468622796366, 0.23557717853526874, 0.6638784974704052, 0.22913160557639461, 0.08236634467587743, 0.339977003899401, 0.36407037103512746, 0.6057556785474101, 0.2208851005212594, 0.19400462334533938, 0.9327603320642109, 0.21927290648533868, 0.727786587197712, 0.5222340998781466, 0.9597824801035595, 0.39342540484360317, 0.8916304709052092, 0.21313001472946488, 0.9797964706250746, 0.05751043738304441, 0.8342027764850524, 0.4528211452252113, 0.4347573233806131, 0.4525411381505408, 0.35685716163304854, 0.9799970768613392, 0.20180396139642268, 0.4605625409537868, 0.7582300192604214, 0.44455481065132474, 0.9167197080840046, 0.9407625684841503, 0.08811121855541283, 0.6765023754723515, 0.665770167332321, 0.5749834538155998, 0.3527438102069729, 0.6909342497128699 };
FAST_DATA_ZERO_INIT static uint8_t output[BENCH_REPEAT*8];

dtype_counters_t benchCounters[BENCH_TEST_COUNT][BENCH_DRIVER_COUNT] = {0};

FAST_CODE_NOINLINE void benchmark_harness(void) {
    uint32_t cycles;

    // important! Individual tests between TIC and TOC must take less than
    // 1 << 31 cycles, otherwise the cycle counter comparison warps the wrong way
    // with 500 MHz clock this is roughly 4 seconds, so should be fine

    // prepare volatile variables
    //BENCH_PREPARE_SCALAR_MULT(int16_t, i16)
    //BENCH_PREPARE_SCALAR_MULT(int32_t, i32)
    //BENCH_PREPARE_SCALAR_MULT(float, f32)
    //BENCH_PREPARE_SCALAR_MULT(double, f64)

    // mult
    // int16
    BENCH_TIC; // disable irq and get current cycles
        scalar_mult_i16(rand_i16, (int16_t*)output, BENCH_REPEAT);
    BENCH_TOC(BENCH_TEST_SCALAR_MULT, BENCH_DRIVER_NAIVE, i16); // write cycle diff and enable irq

    // int32
    BENCH_TIC;
        scalar_mult_i32(rand_i32, (int32_t*)output, BENCH_REPEAT);
    BENCH_TOC(BENCH_TEST_SCALAR_MULT, BENCH_DRIVER_NAIVE, i32);

    // float
    BENCH_TIC;
        scalar_mult_f32(rand_f32, (float*)output, BENCH_REPEAT);
    BENCH_TOC(BENCH_TEST_SCALAR_MULT, BENCH_DRIVER_NAIVE, f32);

    // double
    BENCH_TIC;
        scalar_mult_f64(rand_f64, (double*)output, BENCH_REPEAT);
    BENCH_TOC(BENCH_TEST_SCALAR_MULT, BENCH_DRIVER_NAIVE, f64);


    // float
    BENCH_TIC;
        extern void scalar_mult_f32_asm_4(const float*, float*, int);
        scalar_mult_f32_asm_4(rand_f32, (float*)output, BENCH_REPEAT);
    BENCH_TOC(BENCH_TEST_SCALAR_MULT, BENCH_DRIVER_HANDWRITTEN_4, f32);

    BENCH_TIC;
        extern void scalar_mult_f32_asm_8(const float*, float*, int);
        scalar_mult_f32_asm_8(rand_f32, (float*)output, BENCH_REPEAT);
    BENCH_TOC(BENCH_TEST_SCALAR_MULT, BENCH_DRIVER_HANDWRITTEN_8, f32);

    BENCH_TIC;
        extern void scalar_mult_f32_asm_16(const float*, float*, int);
        scalar_mult_f32_asm_16(rand_f32, (float*)output, BENCH_REPEAT);
    BENCH_TOC(BENCH_TEST_SCALAR_MULT, BENCH_DRIVER_HANDWRITTEN_16, f32);


    // div
    // float
    BENCH_TIC;
        scalar_div_f32(rand_f32, (float*)output, BENCH_REPEAT);
    BENCH_TOC(BENCH_TEST_SCALAR_DIV, BENCH_DRIVER_NAIVE, f32);

    // double
    BENCH_TIC;
        scalar_div_f64(rand_f64, (double*)output, BENCH_REPEAT);
    BENCH_TOC(BENCH_TEST_SCALAR_DIV, BENCH_DRIVER_NAIVE, f64);


    // sqrt
    // float 
    BENCH_TIC;
        scalar_sqrt_f32(rand_f32, (float*)output, BENCH_REPEAT);
    BENCH_TOC(BENCH_TEST_SCALAR_SQRT, BENCH_DRIVER_NAIVE, f32);

    // double
    BENCH_TIC;
        scalar_sqrt_f64(rand_f64, (double*)output, BENCH_REPEAT);
    BENCH_TOC(BENCH_TEST_SCALAR_SQRT, BENCH_DRIVER_NAIVE, f64);

}

#endif
